from time import sleep
from  customtkinter import *
from tkinter import *
from PIL import Image
from tkinter import *
from tkinter import filedialog
from PIL import ImageTk

import os
from math import log
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import psutil

import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt
import os
import cv2

from matplotlib.pyplot import imread

from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split

import numpy as np
from keras import layers
from keras.layers import Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D
from keras.models import Model, load_model
from keras.preprocessing import image
# from keras.utils import layer_utils

from tensorflow.python.keras.utils import layer_utils
# from keras.utils.data_utils import get_file

# from tensorflow.keras.utils import get_file

from keras.applications.imagenet_utils import preprocess_input
import pydot
from IPython.display import SVG
# from keras.utils.vis_utils import model_to_dot
# 
from keras.utils import plot_model

from keras.initializers import glorot_uniform
import scipy.misc
from matplotlib.pyplot import imshow

from keras.initializers import glorot_uniform
from keras.layers import Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D

from keras.models import load_model



last_label_y = 10


def on_mouse_wheel(event):
    canvas.yview_scroll(-1 * (event.delta // 120), "units")



#---IDENTITY BLOCK ---

def identity_block(X, f, filters, stage, block):
       
    # defining name basis
    conv_name_base = 'res' + str(stage) + block + '_branch'
    bn_name_base = 'bn' + str(stage) + block + '_branch'
    
    # Retrieve Filters
    F1, F2, F3 = filters
    
    # Saving the input value.we need this later to add to the output. 
    X_shortcut = X
    
    # First component of main path
    X = Conv2D(filters = F1, kernel_size = (1, 1), strides = (1,1), padding = 'valid', name = conv_name_base + '2a')(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2a')(X)
    X = Activation('relu')(X)

    
    # Second component of main path (≈3 lines)
    X = Conv2D(filters = F2, kernel_size = (f, f), strides = (1,1), padding = 'same', name = conv_name_base + '2b')(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2b')(X)
    X = Activation('relu')(X)

    # Third component of main path (≈2 lines)
    X = Conv2D(filters = F3, kernel_size = (1, 1), strides = (1,1), padding = 'valid', name = conv_name_base + '2c')(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2c')(X)

    # Final step: Add shortcut value to main path, and pass it through a RELU activation 
    X = Add()([X, X_shortcut])
    X = Activation('relu')(X)
    
    
    return X

#---CONVOLUTION BLOCK ---

def convolutional_block(X, f, filters, stage, block, s = 2):
    
    # defining name basis
    conv_name_base = 'res' + str(stage) + block + '_branch'
    bn_name_base = 'bn' + str(stage) + block + '_branch'
    
    # Retrieve Filters
    F1, F2, F3 = filters
    
    # Save the input value
    X_shortcut = X


    # First layer 
    X = Conv2D(F1, (1, 1), strides = (s,s), name = conv_name_base + '2a')(X) # 1,1 is filter size
    X = BatchNormalization(axis = 3, name = bn_name_base + '2a')(X)  # normalization on channels
    X = Activation('relu')(X)

      
    # Second layer  (f,f)=3*3 filter by default
    X = Conv2D(filters = F2, kernel_size = (f, f), strides = (1,1), padding = 'same', name = conv_name_base + '2b')(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2b')(X)
    X = Activation('relu')(X)


    # Third layer
    X = Conv2D(filters = F3, kernel_size = (1, 1), strides = (1,1), padding = 'valid', name = conv_name_base + '2c')(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2c')(X)


    ##### SHORTCUT PATH #### 
    X_shortcut = Conv2D(filters = F3, kernel_size = (1, 1), strides = (s,s), padding = 'valid', name = conv_name_base + '1')(X_shortcut)
    X_shortcut = BatchNormalization(axis = 3, name = bn_name_base + '1')(X_shortcut)

    # Final step: Add shortcut value here, and pass it through a RELU activation 
    X = Add()([X, X_shortcut])
    X = Activation('relu')(X)
    
    
    return X

# CREATING THE RESNET 50

#Each ResNet block is either 2 layer deep
def ResNet50(input_shape=(64, 64, 3), classes=26):
    """
    Implementation of the ResNet50 architecture:
    CONV2D -> BATCHNORM -> RELU -> MAXPOOL -> CONVBLOCK -> IDBLOCK*2 -> CONVBLOCK -> IDBLOCK*3
    -> CONVBLOCK -> IDBLOCK*5 -> CONVBLOCK -> IDBLOCK*2 -> AVGPOOL -> TOPLAYER

    """

    # Define the input as a tensor with shape input_shape
    X_input = Input(input_shape)

    # Zero-Padding
    X = ZeroPadding2D((3, 3))(X_input) #3,3 padding

    # Stage 1
    X = Conv2D(64, (7, 7), strides=(2, 2), name='conv1')(X) #64 filters of 7*7 
    X = BatchNormalization(axis=3, name='bn_conv1')(X) #batchnorm applied on channels
    X = Activation('relu')(X)
    X = MaxPooling2D((3, 3), strides=(2, 2))(X) #window size is 3*3

    # Stage 2
    X = convolutional_block(X, f=3, filters=[64, 64, 256], stage=2, block='a', s=1)
    X = identity_block(X, 3, [64, 64, 256], stage=2, block='b') 
    X = identity_block(X, 3, [64, 64, 256], stage=2, block='c')

    # Stage 3 
    X = convolutional_block(X, f = 3, filters = [128, 128, 512], stage = 3, block='a', s = 2)
    X = identity_block(X, 3, [128, 128, 512], stage=3, block='b')
    X = identity_block(X, 3, [128, 128, 512], stage=3, block='c')
    X = identity_block(X, 3, [128, 128, 512], stage=3, block='d')

    # Stage 4 
    X = convolutional_block(X, f = 3, filters = [256, 256, 1024], stage = 4, block='a', s = 2)
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='b')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='c')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='d')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='e')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='f')

    # Stage 5 
    X = convolutional_block(X, f = 3, filters = [512, 512, 2048], stage = 5, block='a', s = 2)
    X = identity_block(X, 3, [512, 512, 2048], stage=5, block='b')
    X = identity_block(X, 3, [512, 512, 2048], stage=5, block='c')

    # AVGPOOL 
    X = AveragePooling2D((2,2), name="avg_pool")(X)

    # output layer
    X = Flatten()(X)
    X = Dense(classes, activation='softmax', name='fc' + str(classes), kernel_initializer = glorot_uniform(seed=0))(X)
    
    
    # Create model
    model = Model(inputs = X_input, outputs = X, name='ResNet50')

    return model

dataset_path = os.listdir('F://malware_project//datasets//imagedataset//data_img')

room_types = os.listdir('F://malware_project//datasets//imagedataset//data_img')
#print (room_types)  #what kinds of clases are in this dataset

print("Types of rooms found: ", len(dataset_path))
#print(dataset_path[9])

root = "F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//dataRaw"
testing_image='the addres of png of bytefile'
prediction_array = 'array of possibilites'

'''
rooms = []

for item in room_types:
 # Get all the file names
 all_rooms = os.listdir('F://malware_project//datasets//imagedataset//data_img' + '/' +item)
#  print(all_rooms)

 # Add them to the list
 for room in all_rooms:
    rooms.append((item, str('F://malware_project//datasets//imagedataset//data_img' + '/' +item) + '/' + room))
   #  print(rooms[:1])
# Build a dataframe        
rooms_df = pd.DataFrame(data=rooms, columns=['room type', 'image'])
# print(rooms_df.head())
# print(rooms_df.tail())

path = 'F://malware_project//datasets//imagedataset//data_img//'
im_size = 64

images = []
labels = []

for i in room_types:
    data_path = path + str(i)  # entered in 1st folder and then 2nd folder and then 3rd folder
    filenames = [i for i in os.listdir(data_path) ]
   # print(filenames)  # will get the names of all images
    for f in filenames:
        img = cv2.imread(data_path + '/' + f)  # reading that image as array
        #print(img)  # will get the image as an array
        img = cv2.resize(img, (im_size, im_size))
        images.append(img)
        labels.append(i)
# print(labels)

# Transform the image array to a numpy type
images = np.array(images)
print(images.shape)

images = images.astype('float32') / 255.0

from sklearn.preprocessing import LabelEncoder , OneHotEncoder
y=rooms_df['room type'].values
# for y
y_labelencoder = LabelEncoder ()
y = y_labelencoder.fit_transform (y)
# print (y)
y= y.reshape(-1,1)

# onehotencoder = OneHotEncoder(categorical_features=[0])  #Converted  scalar output into vector output where the correct class will be 1 and other will be 0
onehotencoder = OneHotEncoder(sparse=False)
#Converted  scalar output into vector output where the correct class will be 1 and other will be 0
Y= onehotencoder.fit_transform(y)
print(Y.shape)


images, Y = shuffle(images, Y, random_state=1)

train_x, test_x, train_y, test_y = train_test_split(images, Y, test_size=0.3, random_state=415)

#inpect the shape of the training and testing.
print(train_x.shape)
print(train_y.shape)
print(test_x.shape)
print(test_y.shape)

#tryyyyyyyyyyyyyyyyyy praccccccccccccccc

y_train_new = np.argmax(train_y, axis=1)
'''
import tensorflow as tf
a_model = tf.keras.models.load_model('f://mal_model_M_20.keras')
'''
from sklearn.utils import class_weight
class_weights = class_weight.compute_class_weight(class_weight = 'balanced',
                                                 classes = np.unique(y_train_new),
                                                 y = y_train_new)
#class_weights = {i : class_weights[i] for i in range(5)}

class_weights = {l:c for l,c in zip(np.unique(y_train_new), class_weights)}

#------------------------------------------------------------------------------------------------

model = ResNet50(input_shape = (64, 64, 3), classes = 26)

#tryyyyyyyyyyyyyyyyyyyyy pppppppppprrrrrrracccccccccccccc

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

#train_x, test_x, train_y, test_y

model.fit(train_x, train_y, validation_data=(test_x, test_y), epochs=10,  class_weight=class_weights)

model.summary()

model.save('wholefilemodel.h5')

'''


loaded_model = load_model('sfwithownimg_mal_b32_e10_withwts_a95.h5')


# print(loaded_model.summary())


def convert_hexfile_with_system_offsets(input_file, output_file_path,system_defined_offset):
    """
    Converts a raw hexbytes file without offsets to a file with system-defined offsets,
    adhering to the specified formatting requirements.
    """

    with open(input_file, "rb") as infile, open(output_file_path, "w") as outfile:
        offset =  system_defined_offset # Initialize system-defined offset
        while True:
            data = infile.read(16)  # Read 16 bytes at a time
            if not data:
                break  # End of file

            # Format offset with leading zeros to 8 digits
            offset_str = f"{offset:08X}"

            # Convert bytes to space-separated hex pairs
            hex_str = " ".join(f"{b:02X}" for b in data)

            # Write formatted line to output file
            outfile.write(f"{offset_str} {hex_str}\n")

            offset += 16  # Increment offset for the next line

        try :
            inter_convertAndSave(output_file_path)
        except Exception as e:
            print(e)
            print('\n there is an issue with thise file !! plz try with another file')

    




def inter_convertAndSave(path_out_file):

    # passing parameter to call convertAndSAve def

    file_name = os.path.basename(path_out_file)

    if '.bytes' != file_name[-6:]:
        pass

    else:
        f=open(root+'//'+file_name)
        array=[]
        for line in f:
            xx=line.split()
            if len(xx)!=17:
                continue
            array.append([int(i,16) if i!='??' else 0 for i in xx[1:] ])

        plt.imshow(convertAndSave(np.array(array),file_name))

        del array
        f.close()




## This function allows us to process our hexadecimal files into png images##
def convertAndSave(array,name):
    
    global testing_image
    print('Processing '+name)
    if array.shape[1]!=16: #If not hexadecimal
        print('not Processing '+name)
        assert(False)
        
    b=int((array.shape[0]*16)**(0.5))
    b=2**(int(log(b)/log(2))+1)
    a=int(array.shape[0]*16/b)
    array=array[:a*b//16,:]
    array=np.reshape(array,(a,b))
    im = Image.fromarray(np.uint8(array))
    print(im)
    print(root+'//'+name+".png")
    testing_image = root+'//'+name+".png"
    im.save(root+ '//'+name+'.png', "PNG")
    return im

def  show_results():
    global last_label_y
    accuracy_label = CTkLabel(master=frame, text="The given file is  :  ",)
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom

    CATEGORIES = ['Adialer.C', 'Agent.FYI', 'Allaple.A', 'Allaple.L', 'Alueron.gen!J', 'Autorun.K', 'Safe', 'C2LOP.gen!g', 'C2LOP.P', 'Dialplatform.B', 'Dontovo.A', 'Fakerean', 'Instantaccess', 'Lolyda.AA1', 'Lolyda.AA2', 'Lolyda.AA3', 'Lolyda.AT', 'Malex.gen!J', 'Obfuscator.AD', 'Rbot!gen', 'Skintrim.N', 'Swizzor.gen!E', 'Swizzor.gen!I', 'VB.AT', 'Wintrim.BX', 'Yuner.A']
    CATEGORIES_num = np.argmax(prediction_array)
    if(CATEGORIES_num in [9,25, 13 ,6,14]):
        result_label = CTkLabel(master=frame, text='A Safe File',text_color='green')
        canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=result_label, anchor='n')
        last_label_y += 50  # Adjust this value as needed for spacing
        canvas.update_idletasks()
        canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom


        
    else:
        prediction_name = CATEGORIES[CATEGORIES_num]
        result_label = CTkLabel(master=frame, text='Malwared file \nProbable family is : '+prediction_name,text_color='red')
        canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=result_label, anchor='n')
        last_label_y += 50  # Adjust this value as needed for spacing
        canvas.update_idletasks()
        canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom



    
         
    
     
    
def  testing():
    global last_label_y
    global prediction_array
    accuracy_label = CTkLabel(master=frame, text="Analyzing your file",)
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom

     
    # img_path = "F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//dataRaw//test4.png"
    img_path = testing_image
    img = image.load_img(img_path, target_size=(64, 64))
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    x = preprocess_input(x)
    print('Input image shape:', x.shape)
    my_image = imread(img_path)
    imshow(my_image)
    prediction_array = loaded_model.predict(x)
    accuracy_label = CTkLabel(master=frame, text="Your file was analyzed successfully.",)
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom


def test_sample():
    global last_label_y
    global prediction_array
    accuracy_label = CTkLabel(master=frame, text="Choose the converted image of Byte file",)
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom
    
    img_info = filedialog.askopenfile()
    img_path_full = img_info.name
    img_path=img_path_full.replace("/","//")
    # img_path = "F://malware_project//datasets//imagedataset//data_img//VB.AT//00b073351df4351acb03aed8c31794b4.png"

    img = tf.keras.preprocessing.image.load_img(img_path, target_size=(224, 224))
    img_array = tf.keras.preprocessing.image.img_to_array(img)
    img_array = tf.expand_dims(img_array, 0)


    #print(a_model.predict(img_array))
    prediction_array = a_model.predict(img_array)
    print(prediction_array)
    score = tf.nn.softmax(prediction_array[0])
    #streamlit.write(score)
    l= np.argmax(score)
    print (l)

    accuracy_label = CTkLabel(master=frame, text="Your image was analyzed successfully.")
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom



def  select_file():
    global last_label_y
    accuracy_label = CTkLabel(master=frame, text="Processing of your file is underway",text_color='black')
    
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom


    file_info = filedialog.askopenfile()

    file_path_full = file_info.name



    file_path=file_path_full.replace("/","//")

    print('new : ',file_path)
    memory_info = psutil.virtual_memory()
    system_defined_offset =   int(str(memory_info[1]), 16)

    convert_hexfile_with_system_offsets(file_path, root+'//' + os.path.basename(file_path)+'.bytes',system_defined_offset)

    accuracy_label = CTkLabel(master=frame, text="FILE UPLOADED AND TRANSFORMED AS ABOVE IMAGE ",text_color='black')
    sleep(5)
    display_image(testing_image)
    # canvas.create_window((10, last_label_y), window=accuracy_label, anchor='nw')
    canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=accuracy_label, anchor='n')
    last_label_y += 50  # Adjust this value as needed for spacing
    canvas.update_idletasks()
    canvas.configure(scrollregion=canvas.bbox("all"))
    canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom



     
# def display_image(image_path):
#     global last_label_y
    
#     if image_path:
#         # Open the image using PIL
#         image = Image.open(image_path)
    
#         tk_image = ImageTk.PhotoImage(image)
#         image_label = CTkLabel(master=canvas, image=tk_image)
#         image_label.image = tk_image  
#         # canvas.create_window((10, last_label_y), window=image_label, anchor='nw')
#         canvas.create_window((canvas.winfo_width() // 2, last_label_y), window=image_label, anchor='n')
#         last_label_y += image.height + 20  
#         canvas.update_idletasks()
#         canvas.configure(scrollregion=canvas.bbox("all"))
#         canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom

'''
def display_image(image_path):
    global last_label_y
    

    if image_path:
        # Open the image using PIL
        image = Image.open(image_path)
        
        # Get the width and height of the canvas
        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()
        
        # Resize the image to fit within the canvas
        if image.width > canvas_width or image.height > canvas_height:
            ratio = min(canvas_width / image.width, canvas_height / image.height)
            new_width = int(image.width * ratio)
            new_height = int(image.height * ratio)
            image = image.resize((new_width, new_height))
        
        tk_image = ImageTk.PhotoImage(image)
        image_label = CTkLabel(master=canvas, image=tk_image)
        image_label.image = tk_image  
        canvas.create_window((canvas_width // 2, last_label_y), window=image_label, anchor='n')
        last_label_y += new_height + 20  # Use the resized height
        canvas.update_idletasks()
        canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom
'''

def display_image(image_path):
    global last_label_y
    
    if image_path:
        # Open the image using PIL
        image = Image.open(image_path)
        
        # Get the width and height of the canvas
        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()
        
        # Resize the image to fit within the canvas
        ratio = min(canvas_width / image.width, canvas_height / image.height)
        new_width = int(image.width * ratio)
        new_height = int(image.height * ratio)
        image = image.resize((new_width, new_height))
        
        tk_image = ImageTk.PhotoImage(image)
        image_label = CTkLabel(master=canvas, image=tk_image)
        image_label.image = tk_image  
        canvas.create_window((canvas_width // 2, last_label_y), window=image_label, anchor='n')
        last_label_y += new_height + 20  # Use the resized height
        canvas.update_idletasks()
        canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.yview_moveto(1.0)  # Move the scrollbar to the bottom


# def mal_families():
#     # display_image("F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//Images//mal_families.png")
#     display_image("F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//Images//malresixe.jpg")


def exit():
    main.destroy()


main = CTk()
main.title("malware Detection Images using Deep Learning Algorithm") #designing main screen
main.geometry('1000x500')
main.resizable(height = False, width = False)

# main.iconbitmap("C://Users//LOHITH//Downloads//elemii.ico")

frame = CTkFrame(master=main, fg_color='#f0f0f0',corner_radius=16,bg_color='#181436')
# frame = CTkScrollableFrame(master=main, fg_color='#FFFFFF',corner_radius=16,bg_color='#181436')
frame.pack(side='right',expand=True,padx = (200, 0))
frame.configure(width=600,height=400,)
frame.pack_propagate(False)


font = ('times', 21, 'bold')
title = Label(main, text='   malware Detection from Image using Deep Learning Algorithm',justify='center')
title.config( fg='medium orchid',bg='#181436')  
title.config(font=font)           
title.place(x=0,y=5)

font1 = ('times', 18, 'bold')

canvas = Canvas(frame)
scrollbar = Scrollbar(frame, orient="vertical", command=canvas.yview)
scrollbar.pack(side="right", fill="y")
canvas.pack(side="left", fill="both", expand=True)
canvas.configure(yscrollcommand=scrollbar.set)
canvas.bind_all("<MouseWheel>", on_mouse_wheel)  # Bind mouse wheel event to canvas



'''
text=Text(main)
scroll=Scrollbar(text)
text.configure(yscrollcommand=scroll.set)
text.config(font=font1) '''



#  select_file button

img = Image.open('F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//icons//icons//fileupload.png')

cnnButton = CTkButton(main, text="select_file     ", command=select_file,corner_radius=32,bg_color='#181436',width=160,fg_color='#181436',image=CTkImage( light_image=img))
cnnButton.place(x=50,y=140)
cnnButton.configure(font=font1) 


# Analyse button

img = Image.open("F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//icons//icons//upload.png")

cnnButton = CTkButton(main, text="Analyse         ", command=testing,corner_radius=32,bg_color='#181436',width=160,fg_color='#181436',image=CTkImage( light_image=img))
cnnButton.place(x=50,y=190)
cnnButton.configure(font=font1) 

# show results button

img = Image.open("F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//icons//icons//results1.png")

processButton = CTkButton(main, text="results            ", command=show_results,corner_radius=32,bg_color='#181436',width=160,fg_color='#181436',image=CTkImage( light_image=img))
processButton.place(x=50,y=240)
processButton.configure(font=font1)

#  test_sample_ button

img = Image.open('F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//icons//icons//fileupload.png')

cnnButton = CTkButton(main, text="test_sample     ", command=test_sample,corner_radius=32,bg_color='#181436',width=160,fg_color='#181436',image=CTkImage( light_image=img))
cnnButton.place(x=50,y=290)
cnnButton.configure(font=font1) 

#  exit button

img = Image.open("F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//icons//icons//multiply.png")

ExitButton = CTkButton(main, text="Close GUI       ", command=exit,corner_radius=32,bg_color='#181436',width=160,fg_color='#181436',image=CTkImage( light_image=img))
ExitButton.place(x=50,y=340)
ExitButton.configure(font=font1)


# # display_image button

# img = Image.open('F://malware_project//mlimage//malware-image-detection-main//malware-image-detection-main//icons//icons//fileupload.png')
# ExitButton = CTkButton(main, text="display_image      ", command = mal_families,corner_radius=32,bg_color='#181436',width=160,fg_color='#181436',image=CTkImage( light_image=img))
# ExitButton.place(x=50,y=390)
# ExitButton.configure(font=font1)

main.config(bg='#181436')
main.mainloop()